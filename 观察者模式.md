#观察者模式
###游戏编程模式：重温设计模式
你不能朝一台电脑扔石头如果你不击中一个使用MVC框架并以观察者模式为基础的应用程序。（这一段是什么鬼=_=）观察者模式十分流行，以至于Java将它放入了它的核心类库(java.util.Observer)，而另一个面向对象语言C#则将观察者模式集成到它的语言特性之中（即event关键字）。

就像其他许多软件行业中的事物一样，MVC是由Smalltalkers公司于上世纪70年代发明的。Lisp使用者可能会宣称他们早在上世纪60年代就提出了这个概念，只是因为觉得麻烦而没有写出来。

观察者模式是最初Gang of Four提出的设计模式中使用最广泛也是最为著名的设计模式之一，但是游戏开发世界有时又会给人一种一种不可思议的与世隔绝感，所以这可能就是我所能告诉你的全部的信息。如果一会儿之后你还没有离开游戏世界这座‘大修道院’，就让我带你走进一个令人激动的栗子中吧。

##成就解锁
假设我们要往我们的游戏中添加一个成就系统。这个系统最重要的是一系列各种各样的玩家可以通过完成特定的里程碑式任务比如‘杀死一百只猴子怪’或是‘从桥上掉下来(作死大法好)

![](https://github.com/klvj/GameProgrammingPattern/raw/master/IMG/ob-1.png)

我发誓我画这个的时候没有其他意思！

当我们有这样广泛的可以由各种不同的行为解锁的各种各样的成就时，要想再让系统保持整洁就变得十分棘手。如果我们不小心谨慎的处理的话，我们这个庞大的成就系统的卷须就会缠绕着穿过我们代码中每一个黑暗的角落。当然，‘从桥上掉下来’从某种程度上来说应当与物理引擎有所关联，但是我们真的希望在我们的物理引擎的冲突解决算法的线性代数部分出现一个对函数unlockFallOffBridge()的调用吗？

这是一个反问句(我当然看得出来是反问句=_=)。不懂得自我尊重的物理引擎程序员竟会因为一些类似游戏设置的普通东西而让我们玷污了他们美丽的数学。

我们一如既往想要的，是所有的代码都很好的集中在一个地方，并只关心游戏的一个方面。在这方面会遇到的挑战是，成就是由一堆来自各个方向的游戏事件触发的。我们要如何设计，才能让成就系统的代码不与他们产生耦合？

这就是观察者模式存在的意义。它让一段代码宣布，“嘿，这儿有一件有趣的事发生了”，并且从不关心谁会收到这段通知。

举个栗子，我们这里有一段代码用于处理放在一个表面抛光的平面上的人或动物的身体在直线下降时的重力和轨迹。为了实现’从桥上掉下去‘这个成就的徽章，我们可以就在那儿写一段shi一样的代码，但这毕竟是一坨shi。相反，如果我们这样写：

	void Physics::updateEntity(Entity& entity)
	{
		bool wasOnSurface = entity.isOnSurface();
		entity.accelerate(GRAVITY);
		entity.update();
		if (wasOnSurface && !entity.isOnSurface())
		{
			notify(entity, EVENT_START_FALL);
		}
	}
	
这段代码做的所有事情就像是在说:"嘿，我不知道是否有人在乎，但这只是无关紧要的东西。做你想做的事情去吧。"

物理引擎仍然需要决定发送哪一个通知，因此它并没有达到完全解耦。但是在系统架构时，我们做的最多的尝试是试着让系统往变得更好的方向上走，而不是一定要完美无缺。

成就系统注册自己，这样无论何时，只要物理引擎的那段代码发送了通知，成就系统就能马上收到它。成就系统接下来马上能检测到如果正在掉落的东西是我们主角那令人感受不到一丝优美的BODY，并且在与古典力学发生某些新鲜的，令人不愉快的邂逅之前，它的栖息点是在桥上的话，那么就会解锁特有的成就，解锁时会伴有烟花和号角。并且你可以发现，做完这一切之后，没有一行物理引擎相关的代码卷入其中。

事实上，我们可以在不动一行物理引擎代码的情况下更改整个成就集合或者将整个成就系统移植到别处。物理引擎处的那一段代码依然会静静的发送通知，并且无视没有人会收到这些通知的事实。

当然，如果我们永久的删除了某个成就并因此导致没有任何别的代码会收到物理引擎的那段代码所发送的通知，我们最好同时删除掉这一段发送通知的代码。但是在整个游戏的更新过程中，拥有灵活性显然更好。

##观察者模式如何工作
如果你确实不知道要怎么去实现观察者模式，你可能只能从之前的内容里猜测它的大概运行方式，但是为了让你更加明白，接下来我将会快速的带你体会一遍。

###观察者
我们从一个喜欢爱管闲事的老是想打听别的其他对象在干什么有趣的事的类开始。这些爱多管闲事的对象由下面这些接口定义：
	class Observer
	{
		public:
		virtual ~Observer() {}
		virtual void onNotify(const Entity& entity, Event event) = 0;
	};
	
	
onNotify()函数的参数由你决定。这就是为什么这叫做观察者模式而不是叫做“代码现成可直接拷进项目”的观察者先生。典型的参数是发送通知的对象和一个包含了你要做的事情的细节的通用的数据参数。

如果你使用的编程语言支持泛型或模板，在这里你可能会用上它们，如果只是用于定制你的具体需求也没有什么问题。在这里，我直接用硬编码的方式，选择使用一个游戏实体类和一个描述发生了什么事情的枚举类型。

任何继承了这个接口的实体类都将会成为一个观察者。在我们的栗子里，这个观察者是成就系统，所以我们有一些类似于下面的事情可以做：
class Achievements : public Observer
{
	public:
	virtual void onNotify(const Entity& entity, Event event)
	{
		switch (event)
		{
		case EVENT_ENTITY_FELL:
			if (entity.isHero() && heroIsOnBridge_)
			{
				unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);
			}
			break;
			// Handle other events, and update heroIsOnBridge_...
			}
	}
	private:
	void unlock(Achievement achievement)
	{
		// Unlock if not already unlocked...
	}
	bool heroIsOnBridge_;
};



